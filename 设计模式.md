23种设计模式
======
1.单例模式（Singleton Pattern）
6种
1.1懒汉式 线程不安全
是否 Lazy 初始化：是
是否多线程安全：否
实现难度：易
    
    public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
  
    public static Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
    }
1.2懒汉式 线程安全
是否 Lazy 初始化：是
是否多线程安全：是
实现难度：易

    public class Singleton {  
        private static Singleton instance;  
        private Singleton (){}  
        public static synchronized Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
        }  
    }
 1.3饿汉式
是否 Lazy 初始化：否
是否多线程安全：是
实现难度：易

    public class Singleton {  
        private static Singleton instance = new Singleton();  
        private Singleton (){}  
        public static Singleton getInstance() {  
        return instance;  
        }  
    }
1.4双检锁/双重校验锁（DCL，即 double-checked locking）
JDK 版本：JDK1.5 起
是否 Lazy 初始化：是
是否多线程安全：是

    public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
    }
1.5静态内部类
是否 Lazy 初始化：是
是否多线程安全：是

    public class Singleton {  
        private static class SingletonHolder {  
        private static final Singleton INSTANCE = new Singleton();  
        }  
        private Singleton (){}  
        public static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE;  
        }  
    }
1.6枚举
JDK 版本：JDK1.5 起。这是实现单例模式的最佳方法，Effective Java 作者 Josh Bloch 提倡的方式，支持序列化机制，绝对防止多次实例化。
是否 Lazy 初始化：否
是否多线程安全：是

    public enum Singleton {  
        INSTANCE;  
        public void whateverMethod() {  
        }  
    }
经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。

2.工厂模式

3.抽象工厂模式（Abstract Factory Pattern）

4.模板方法模式（Template Method Pattern）

5.建造者模式（Builder Pattern）

6.代理模式（Proxy Pattern）

7.原型模式（Prototype Pattern）

8.中介者模式


9.命令模式
10.责任链模式

11.装饰模式（Decorator Pattern）

12.策略模式（Strategy Pattern）
行为参数化，通过定义一个接口来对选择标准建模，比如说:

    public inteface applePrediect{
     boolean test(Apple apple);
    }

可以用不同的实现来代表不同的选择标准,比如:

    public class AppleHeavyWeightPredicate implements ApplePredicate{
      public boolean test(Apple apple){
        return apple.getWeight() > 150;
      } 
    } 

    public class AppleGreenColorPredicate implements ApplePredicate{
      public boolean test(Apple apple){
        return "green".equals(apple.getColor());
      } 
    }

你可以把这些标准看作filter方法的不同行为。你刚做的这些和“策略设计模式”①相关， 它让你定义一族算法，把它们封装起来（称为“策略”），然后在运行时选择一个算法。
在这里， 算法族就是ApplePredicate，不同的策略就是AppleHeavyWeightPredicate和AppleGreen- ColorPredicate。 但是，该怎么利用ApplePredicate的不同实现呢？
你需要filterApples方法接受 ApplePredicate对象，对Apple做条件测试。这就是行为参数化：让方法接受多种行为（或战 略）作为参数，并在内部使用，来完成不同的行为。
要在我们的例子中实现这一点，你要给filterApples方法添加一个参数，让它接受 ApplePredicate对象。这在软件工程上有很大好处：现在你把filterApples方法迭代集合的
逻辑与你要应用到集合中每个元素的行为（这里是一个谓词）区分开了。 
利用ApplePredicate改过之后，filter方法看起来是这样的： 

    public static List<Apple> filterApples(List<Apple> inventory,ApplePredicate p){ 
      List<Apple> result = new ArrayList<>(); 
        for(Apple apple: inventory){ 
          if(p.test(apple)){  
            result.add(apple);  
          }  
        } 
      return result; 
    } 
找出所有重量超过150克的红苹果，你只需要创建一 个类来实现ApplePredicate就行了。
    
    public class AppleRedAndHeavyPredicate implements ApplePredicate{
      public boolean test(Apple apple){
      return "red".equals(apple.getColor()) && apple.getWeight() > 150;
      } 
     } 
    List<Apple> redAndHeavyApples = filterApples(inventory, new AppleRedAndHeavyPredicate()); 
但令人遗憾的是，由于该filterApples方法只能接受对象， 所以你必须把代码包裹在ApplePredicate对象里。你的做法就类似于在内联“传递代码”，因 为你是通过一个实现了test方法的对象来传递布尔表达式的。通过使用Lambda，你可以直接把表达式"red".equals(apple.getColor()) &&apple.getWeight() > 150传递给filterApples方法，而无需定义多个ApplePredicate 类，从而去掉不必要的代码。
匿名内部类也可以实现。
但匿名类还是不够好。第一，它往往很笨重，因为它占用了很多空间。还拿前面的例子来看，如下面代码所示：

    List<Apple> redApples = filterApples(inventory, new ApplePredicate() {
      public boolean test(Apple a){  
        return "red".equals(a.getColor()); 
        } 
       }); 
Java FX API
    
    button.setOnAction(new EventHandler<ActionEvent>() { 
      public void handle(ActionEvent event) { 
        System.out.println("Woooo a click!!");
      } 
    }); 
第二，很多程序员觉得它用起来很让人费解。
使用lambda表达式
    
    List<Apple> redApples = filterApples(inventory,(Apple apple) -> "red".equals(apple.getColor()));
13.适配器模式（Adapter Pattern）

