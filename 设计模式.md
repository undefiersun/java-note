23种设计模式
======
1.单例模式（Singleton Pattern）
-----
6种

1.1懒汉式 线程不安全
是否 Lazy 初始化：是
是否多线程安全：否
实现难度：易
    
    public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
  
    public static Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
    }
1.2懒汉式 线程安全
是否 Lazy 初始化：是
是否多线程安全：是
实现难度：易

    public class Singleton {  
        private static Singleton instance;  
        private Singleton (){}  
        public static synchronized Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
        }  
    }
 1.3饿汉式
是否 Lazy 初始化：否
是否多线程安全：是
实现难度：易

    public class Singleton {  
        private static Singleton instance = new Singleton();  
        private Singleton (){}  
        public static Singleton getInstance() {  
        return instance;  
        }  
    }
1.4双检锁/双重校验锁（DCL，即 double-checked locking）
JDK 版本：JDK1.5 起
是否 Lazy 初始化：是
是否多线程安全：是

    public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
    }
1.5静态内部类
是否 Lazy 初始化：是
是否多线程安全：是

    public class Singleton {  
        private static class SingletonHolder {  
        private static final Singleton INSTANCE = new Singleton();  
        }  
        private Singleton (){}  
        public static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE;  
        }  
    }
1.6枚举
JDK 版本：JDK1.5 起。这是实现单例模式的最佳方法，Effective Java 作者 Josh Bloch 提倡的方式，支持序列化机制，绝对防止多次实例化。
是否 Lazy 初始化：否
是否多线程安全：是

    public enum Singleton {  
        INSTANCE;  
        public void whateverMethod() {  
        }  
    }
经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。

2.工厂模式
-------
在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。


    public interface Shape {
    void draw();
    }
    public class Rectangle implements Shape {
        @Override
        public void draw() {
        System.out.println("Inside Rectangle::draw() method.");
        }
    }
    public class Square implements Shape {
        @Override
        public void draw() {
            System.out.println("Inside Square::draw() method.");
        }
    }
    public class Circle implements Shape {
        @Override
        public void draw() {
        System.out.println("Inside Circle::draw() method.");
    }
    }
    public class ShapeFactory {
    
    //使用 getShape 方法获取形状类型的对象
    public Shape getShape(String shapeType){
        if(shapeType == null){
            return null;
        }        
        if(shapeType.equalsIgnoreCase("CIRCLE")){
            return new Circle();
        } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
            return new Rectangle();
        } else if(shapeType.equalsIgnoreCase("SQUARE")){
             return new Square();
        }
          return null;
    }
    }

3.抽象工厂模式（Abstract Factory Pattern）
-----
抽象工厂：提供了产品的生成方法。

    interface AbstractFactory
    {
    public Product1 newProduct1();
    public Product2 newProduct2();
    }
具体工厂：实现了产品的生成方法。

    class ConcreteFactory1 implements AbstractFactory
    {
    public Product1 newProduct1()
    {
        System.out.println("具体工厂 1 生成-->具体产品 11...");
        return new ConcreteProduct11();
    }
    public Product2 newProduct2()
    {
        System.out.println("具体工厂 1 生成-->具体产品 21...");
        return new ConcreteProduct21();
    }
    }
    

4.原型模式（Prototype Pattern）
-------
何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。 
深拷贝代码如下

        public Shape deepClone() throws IOException,ClassNotFoundException{
        //将对象写入流中
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
        objectOutputStream.writeObject(this);
        //从流中取出
        ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
        return (Shape)objectInputStream.readObject();
        }

5.建造者模式（Builder Pattern）
--------

我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。
我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。
然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。

![image](https://github.com/undefiersun/java-note/blob/master/images/builder_pattern_uml_diagram.jpg)

创建一个表示食物条目和食物包装的接口。

    public interface Item {
     public String name();
    public Packing packing();
    public float price();    
    }
    
    public interface Packing {
     public String pack();
    }
创建实现 Packing 接口的实体类。
包装纸
        
        public class Wrapper implements Packing {
            @Override
            public String pack() {
            return "Wrapper";
            }
        }
瓶子

    public class Bottle implements Packing {
        @Override
        public String pack() {
        return "Bottle";
        }
    }

    public abstract class Burger implements Item {
 
       @Override
       public Packing packing() {
          return new Wrapper();
       }

       @Override
       public abstract float price();
    }
    
    public abstract class ColdDrink implements Item {
 
    @Override
    public Packing packing() {
       return new Bottle();
    }
 
    @Override
    public abstract float price();
    }
    
    public class VegBurger extends Burger {
 
       @Override
       public float price() {
          return 25.0f;
       }

       @Override
       public String name() {
          return "Veg Burger";
       }
    }
    
    public class ChickenBurger extends Burger {
 
       @Override
       public float price() {
          return 50.5f;
       }

       @Override
       public String name() {
          return "Chicken Burger";
       }
    }
    
    public class Coke extends ColdDrink {
 
       @Override
       public float price() {
          return 30.0f;
       }

       @Override
       public String name() {
          return "Coke";
       }
    }
    
    public class Pepsi extends ColdDrink {
 
       @Override
       public float price() {
          return 35.0f;
       }

       @Override
       public String name() {
          return "Pepsi";
       }
    }
    
创建一个 Meal 类，带有上面定义的 Item 对象。

    import java.util.ArrayList;
    import java.util.List;

    public class Meal {
       private List<Item> items = new ArrayList<Item>();    

       public void addItem(Item item){
          items.add(item);
       }

       public float getCost(){
          float cost = 0.0f;
          for (Item item : items) {
             cost += item.price();
          }        
          return cost;
       }

       public void showItems(){
          for (Item item : items) {
             System.out.print("Item : "+item.name());
             System.out.print(", Packing : "+item.packing().pack());
             System.out.println(", Price : "+item.price());
          }        
       }    
    }
 创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。
 
    public class MealBuilder {

       public Meal prepareVegMeal (){
          Meal meal = new Meal();
          meal.addItem(new VegBurger());
          meal.addItem(new Coke());
          return meal;
       }   

       public Meal prepareNonVegMeal (){
          Meal meal = new Meal();
          meal.addItem(new ChickenBurger());
          meal.addItem(new Pepsi());
          return meal;
       }
    }

BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。

    public class BuilderPatternDemo {
        public static void main(String[] args) {
            MealBuilder mealBuilder = new MealBuilder();
 
            Meal vegMeal = mealBuilder.prepareVegMeal();
            System.out.println("Veg Meal");
            vegMeal.showItems();
            System.out.println("Total Cost: " +vegMeal.getCost());
 
            Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
            System.out.println("\n\nNon-Veg Meal");
            nonVegMeal.showItems();
            System.out.println("Total Cost: " +nonVegMeal.getCost());
        }
    }
执行程序，输出结果：

        Veg Meal
        Item : Veg Burger, Packing : Wrapper, Price : 25.0
        Item : Coke, Packing : Bottle, Price : 30.0
        Total Cost: 55.0


        Non-Veg Meal
        Item : Chicken Burger, Packing : Wrapper, Price : 50.5
        Item : Pepsi, Packing : Bottle, Price : 35.0
        Total Cost: 85.5
6.代理模式（Proxy Pattern）
----
抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。
代理模式的实现

    package proxy;
    public class ProxyTest
    {
        public static void main(String[] args)
        {
            Proxy proxy=new Proxy();
            proxy.Request();
        }
    }
    //抽象主题
    interface Subject
    {
        void Request();
    }
    //真实主题
    class RealSubject implements Subject
    {
        public void Request()
        {
            System.out.println("访问真实主题方法...");
        }
    }
    //代理
    class Proxy implements Subject
    {
        private RealSubject realSubject;
        public void Request()
        {
            if (realSubject==null)
            {
                realSubject=new RealSubject();
            }
            preRequest();
            realSubject.Request();
            postRequest();
        }
        public void preRequest()
        {
            System.out.println("访问真实主题之前的预处理。");
        }
        public void postRequest()
        {
            System.out.println("访问真实主题之后的后续处理。");
        }
    }

7.适配器模式（Adapter Pattern）
----
在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。

在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。

适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

该模式的主要优点如下。 
客户端通过适配器可以透明地调用目标接口。
复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。

其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。
类适配器模式代码如下

    package adapter;
    //目标接口
    interface Target
    {
        public void request();
    }
    //适配者接口
    class Adaptee
    {
        public void specificRequest()
        {       
            System.out.println("适配者中的业务代码被调用！");
        }
    }
    //类适配器类
    class ClassAdapter extends Adaptee implements Target
    {
        public void request()
        {
            specificRequest();
        }
    }
    //客户端代码
    public class ClassAdapterTest
    {
        public static void main(String[] args)
        {
            System.out.println("类适配器模式测试：");
            Target target = new ClassAdapter();
            target.request();
        }
    }
    
对象适配器模式的代码如下

    package adapter;
    //对象适配器类
    class ObjectAdapter implements Target
    {
        private Adaptee adaptee;
        public ObjectAdapter(Adaptee adaptee)
        {
            this.adaptee=adaptee;
        }
        public void request()
        {
            adaptee.specificRequest();
        }
    }
    //客户端代码
    public class ObjectAdapterTest
    {
        public static void main(String[] args)
        {
            System.out.println("对象适配器模式测试：");
            Adaptee adaptee = new Adaptee();
            Target target = new ObjectAdapter(adaptee);
            target.request();
        }
    }

8.桥接模式
-----
桥接（Bridge）模式包含以下主要角色。 
抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。
扩展抽象化（Refined    Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。
具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。

桥接模式代码如下

        package bridge;
        public class BridgeTest
        {
            public static void main(String[] args)
            {
                Implementor imple=new ConcreteImplementorA();
                Abstraction abs=new RefinedAbstraction(imple);
                abs.Operation();
            }
        }
        //实现化角色
        interface Implementor
        {
            public void OperationImpl();
        }
        //具体实现化角色
        class ConcreteImplementorA implements Implementor
        {
            public void OperationImpl()
            {
                System.out.println("具体实现化(Concrete Implementor)角色被访问" );
            }
        }
        //抽象化角色
        abstract class Abstraction
        {
           protected Implementor imple;
           protected Abstraction(Implementor imple)
           {
               this.imple=imple;
           }
           public abstract void Operation();   
        }
        //扩展抽象化角色
        class RefinedAbstraction extends Abstraction
        {
           protected RefinedAbstraction(Implementor imple)
           {
               super(imple);
           }
           public void Operation()
           {
               System.out.println("扩展抽象化(Refined Abstraction)角色被访问" );
               imple.OperationImpl();
           }
        }


9.装饰模式（Decorator Pattern）
-------
装饰（Decorator）模式的主要优点有： 
采用装饰模式扩展对象的功能比采用继承方式更加灵活。
可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。

装饰模式主要包含以下角色。 
抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
具体构件（Concrete    Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。
抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

装饰模式的实现代码如下： 

    package decorator;
    public class DecoratorPattern
    {
        public static void main(String[] args)
        {
            Component p=new ConcreteComponent();
            p.operation();
            System.out.println("---------------------------------");
            Component d=new ConcreteDecorator(p);
            d.operation();
        }
    }
    //抽象构件角色
    interface  Component
    {
        public void operation();
    }
    //具体构件角色
    class ConcreteComponent implements Component
    {
        public ConcreteComponent()
        {
            System.out.println("创建具体构件角色");       
        }   
        public void operation()
        {
            System.out.println("调用具体构件角色的方法operation()");           
        }
    }
    //抽象装饰角色
    class Decorator implements Component
    {
        private Component component;   
        public Decorator(Component component)
        {
            this.component=component;
        }   
        public void operation()
        {
            component.operation();
        }
    }
    //具体装饰角色
    class ConcreteDecorator extends Decorator
    {
        public ConcreteDecorator(Component component)
        {
            super(component);
        }   
        public void operation()
        {
            super.operation();
            addedFunction();
        }
        public void addedFunction()
        {
            System.out.println("为具体构件角色增加额外的功能addedFunction()");           
        }
    }
    

10.外观模式
-------
外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

    public interface Shape {
    void draw();
    }

    public class Rectangle implements Shape {

       @Override
       public void draw() {
          System.out.println("Rectangle::draw()");
       }
    }
    
    public class Square implements Shape {
 
       @Override
       public void draw() {
          System.out.println("Square::draw()");
       }
    }
    
    public class Circle implements Shape {
 
       @Override
       public void draw() {
          System.out.println("Circle::draw()");
       }
    }
    
创建一个外观类

       public class ShapeMaker {
       private Shape circle;
       private Shape rectangle;
       private Shape square;

       public ShapeMaker() {
          circle = new Circle();
          rectangle = new Rectangle();
          square = new Square();
       }

       public void drawCircle(){
          circle.draw();
       }
       public void drawRectangle(){
          rectangle.draw();
       }
       public void drawSquare(){
          square.draw();
       }
       }
       
    public class FacadePatternDemo {
    public static void main(String[] args) {
    ShapeMaker shapeMaker = new ShapeMaker();
      shapeMaker.drawCircle();
      shapeMaker.drawRectangle();
      shapeMaker.drawSquare();      
     }
    }   
 
11.享元模式
-------

12.组合模式
-------

13.模板方法模式
-------

14.策略模式（Strategy Pattern）
------
行为参数化，通过定义一个接口来对选择标准建模，比如说:

    public inteface applePrediect{
     boolean test(Apple apple);
    }

可以用不同的实现来代表不同的选择标准,比如:

    public class AppleHeavyWeightPredicate implements ApplePredicate{
      public boolean test(Apple apple){
        return apple.getWeight() > 150;
      } 
    } 

    public class AppleGreenColorPredicate implements ApplePredicate{
      public boolean test(Apple apple){
        return "green".equals(apple.getColor());
      } 
    }

你可以把这些标准看作filter方法的不同行为。你刚做的这些和“策略设计模式”①相关， 它让你定义一族算法，把它们封装起来（称为“策略”），然后在运行时选择一个算法。
在这里， 算法族就是ApplePredicate，不同的策略就是AppleHeavyWeightPredicate和AppleGreen- ColorPredicate。 但是，该怎么利用ApplePredicate的不同实现呢？
你需要filterApples方法接受 ApplePredicate对象，对Apple做条件测试。这就是行为参数化：让方法接受多种行为（或战 略）作为参数，并在内部使用，来完成不同的行为。
要在我们的例子中实现这一点，你要给filterApples方法添加一个参数，让它接受 ApplePredicate对象。这在软件工程上有很大好处：现在你把filterApples方法迭代集合的
逻辑与你要应用到集合中每个元素的行为（这里是一个谓词）区分开了。 
利用ApplePredicate改过之后，filter方法看起来是这样的： 

    public static List<Apple> filterApples(List<Apple> inventory,ApplePredicate p){ 
      List<Apple> result = new ArrayList<>(); 
        for(Apple apple: inventory){ 
          if(p.test(apple)){  
            result.add(apple);  
          }  
        } 
      return result; 
    } 
找出所有重量超过150克的红苹果，你只需要创建一 个类来实现ApplePredicate就行了。
    
    public class AppleRedAndHeavyPredicate implements ApplePredicate{
      public boolean test(Apple apple){
      return "red".equals(apple.getColor()) && apple.getWeight() > 150;
      } 
     } 
    List<Apple> redAndHeavyApples = filterApples(inventory, new AppleRedAndHeavyPredicate()); 
但令人遗憾的是，由于该filterApples方法只能接受对象， 所以你必须把代码包裹在ApplePredicate对象里。你的做法就类似于在内联“传递代码”，因 为你是通过一个实现了test方法的对象来传递布尔表达式的。通过使用Lambda，你可以直接把表达式"red".equals(apple.getColor()) &&apple.getWeight() > 150传递给filterApples方法，而无需定义多个ApplePredicate 类，从而去掉不必要的代码。
匿名内部类也可以实现。
但匿名类还是不够好。第一，它往往很笨重，因为它占用了很多空间。还拿前面的例子来看，如下面代码所示：

    List<Apple> redApples = filterApples(inventory, new ApplePredicate() {
      public boolean test(Apple a){  
        return "red".equals(a.getColor()); 
        } 
       }); 
Java FX API
    
    button.setOnAction(new EventHandler<ActionEvent>() { 
      public void handle(ActionEvent event) { 
        System.out.println("Woooo a click!!");
      } 
    }); 
第二，很多程序员觉得它用起来很让人费解。
使用lambda表达式
    
    List<Apple> redApples = filterApples(inventory,(Apple apple) -> "red".equals(apple.getColor()));
15.命令模式
--------

16.责任链模式
--------

17.状态模式
---------

18.观察者模式
---------

19.中介者模式
---------

20.迭代器模式
---------

21.访问者模式
----------

22.备忘录模式
----------

23.解释器模式
----------

