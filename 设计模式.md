23种设计模式
======
1.单例模式（Singleton Pattern）

2.工厂模式

3.抽象工厂模式（Abstract Factory Pattern）

4.模板方法模式（Template Method Pattern）

5.建造者模式（Builder Pattern）

6.代理模式（Proxy Pattern）

7.原型模式（Prototype Pattern）

8.中介者模式


9.命令模式
10.责任链模式

11.装饰模式（Decorator Pattern）

12.策略模式（Strategy Pattern）
行为参数化，通过定义一个接口来对选择标准建模，比如说:

    public inteface applePrediect{
     boolean test(Apple apple);
    }

可以用不同的实现来代表不同的选择标准,比如:

    public class AppleHeavyWeightPredicate implements ApplePredicate{
      public boolean test(Apple apple){
        return apple.getWeight() > 150;
      } 
    } 

    public class AppleGreenColorPredicate implements ApplePredicate{
      public boolean test(Apple apple){
        return "green".equals(apple.getColor());
      } 
    }

你可以把这些标准看作filter方法的不同行为。你刚做的这些和“策略设计模式”①相关， 它让你定义一族算法，把它们封装起来（称为“策略”），然后在运行时选择一个算法。
在这里， 算法族就是ApplePredicate，不同的策略就是AppleHeavyWeightPredicate和AppleGreen- ColorPredicate。 但是，该怎么利用ApplePredicate的不同实现呢？
你需要filterApples方法接受 ApplePredicate对象，对Apple做条件测试。这就是行为参数化：让方法接受多种行为（或战 略）作为参数，并在内部使用，来完成不同的行为。
要在我们的例子中实现这一点，你要给filterApples方法添加一个参数，让它接受 ApplePredicate对象。这在软件工程上有很大好处：现在你把filterApples方法迭代集合的
逻辑与你要应用到集合中每个元素的行为（这里是一个谓词）区分开了。 
利用ApplePredicate改过之后，filter方法看起来是这样的： 

    public static List<Apple> filterApples(List<Apple> inventory,ApplePredicate p){ 
      List<Apple> result = new ArrayList<>(); 
        for(Apple apple: inventory){ 
          if(p.test(apple)){  
            result.add(apple);  
          }  
        } 
      return result; 
    } 
找出所有重量超过150克的红苹果，你只需要创建一 个类来实现ApplePredicate就行了。
    
    public class AppleRedAndHeavyPredicate implements ApplePredicate{
      public boolean test(Apple apple){
      return "red".equals(apple.getColor()) && apple.getWeight() > 150;
      } 
     } 
    List<Apple> redAndHeavyApples = filterApples(inventory, new AppleRedAndHeavyPredicate()); 
但令人遗憾的是，由于该filterApples方法只能接受对象， 所以你必须把代码包裹在ApplePredicate对象里。你的做法就类似于在内联“传递代码”，因 为你是通过一个实现了test方法的对象来传递布尔表达式的。通过使用Lambda，你可以直接把表达式"red".equals(apple.getColor()) &&apple.getWeight() > 150传递给filterApples方法，而无需定义多个ApplePredicate 类，从而去掉不必要的代码。
匿名内部类也可以实现。
但匿名类还是不够好。第一，它往往很笨重，因为它占用了很多空间。还拿前面的例子来看，如下面代码所示：

    List<Apple> redApples = filterApples(inventory, new ApplePredicate() {
      public boolean test(Apple a){  
        return "red".equals(a.getColor()); 
        } 
       }); 
Java FX API
    
    button.setOnAction(new EventHandler<ActionEvent>() { 
      public void handle(ActionEvent event) { 
        System.out.println("Woooo a click!!");
      } 
    }); 
第二，很多程序员觉得它用起来很让人费解。
使用lambda表达式
    
    List<Apple> redApples = filterApples(inventory,(Apple apple) -> "red".equals(apple.getColor()));
13.适配器模式（Adapter Pattern）

