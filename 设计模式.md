23种设计模式
======
设计模式按类型分为创建型、结构型、行为型模式。

1.单例模式（Singleton Pattern）
-----
6种

1.1懒汉式 线程不安全
是否 Lazy 初始化：是
是否多线程安全：否
实现难度：易
    
    public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
  
    public static Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
    }
1.2懒汉式 线程安全
是否 Lazy 初始化：是
是否多线程安全：是
实现难度：易

    public class Singleton {  
        private static Singleton instance;  
        private Singleton (){}  
        public static synchronized Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
        }  
    }
 1.3饿汉式
是否 Lazy 初始化：否
是否多线程安全：是
实现难度：易

    public class Singleton {  
        private static Singleton instance = new Singleton();  
        private Singleton (){}  
        public static Singleton getInstance() {  
        return instance;  
        }  
    }
1.4双检锁/双重校验锁（DCL，即 double-checked locking）
JDK 版本：JDK1.5 起
是否 Lazy 初始化：是
是否多线程安全：是

    public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
    }
1.5静态内部类
是否 Lazy 初始化：是
是否多线程安全：是

    public class Singleton {  
        private static class SingletonHolder {  
        private static final Singleton INSTANCE = new Singleton();  
        }  
        private Singleton (){}  
        public static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE;  
        }  
    }
1.6枚举
JDK 版本：JDK1.5 起。这是实现单例模式的最佳方法，Effective Java 作者 Josh Bloch 提倡的方式，支持序列化机制，绝对防止多次实例化。
是否 Lazy 初始化：否
是否多线程安全：是

    public enum Singleton {  
        INSTANCE;  
        public void whateverMethod() {  
        }  
    }
经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。

2.工厂模式
-------
在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。


    public interface Shape {
    void draw();
    }
    public class Rectangle implements Shape {
        @Override
        public void draw() {
        System.out.println("Inside Rectangle::draw() method.");
        }
    }
    public class Square implements Shape {
        @Override
        public void draw() {
            System.out.println("Inside Square::draw() method.");
        }
    }
    public class Circle implements Shape {
        @Override
        public void draw() {
        System.out.println("Inside Circle::draw() method.");
    }
    }
    public class ShapeFactory {
    
    //使用 getShape 方法获取形状类型的对象
    public Shape getShape(String shapeType){
        if(shapeType == null){
            return null;
        }        
        if(shapeType.equalsIgnoreCase("CIRCLE")){
            return new Circle();
        } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
            return new Rectangle();
        } else if(shapeType.equalsIgnoreCase("SQUARE")){
             return new Square();
        }
          return null;
    }
    }

3.抽象工厂模式（Abstract Factory Pattern）
-----
抽象工厂：提供了产品的生成方法。

    interface AbstractFactory
    {
    public Product1 newProduct1();
    public Product2 newProduct2();
    }
具体工厂：实现了产品的生成方法。

    class ConcreteFactory1 implements AbstractFactory
    {
    public Product1 newProduct1()
    {
        System.out.println("具体工厂 1 生成-->具体产品 11...");
        return new ConcreteProduct11();
    }
    public Product2 newProduct2()
    {
        System.out.println("具体工厂 1 生成-->具体产品 21...");
        return new ConcreteProduct21();
    }
    }
    

4.原型模式（Prototype Pattern）
-------
何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。 
深拷贝代码如下

        public Shape deepClone() throws IOException,ClassNotFoundException{
        //将对象写入流中
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
        objectOutputStream.writeObject(this);
        //从流中取出
        ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
        return (Shape)objectInputStream.readObject();
        }

5.建造者模式（Builder Pattern）
--------

我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。
我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。
然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。

![image](https://github.com/undefiersun/java-note/blob/master/images/builder_pattern_uml_diagram.jpg)

创建一个表示食物条目和食物包装的接口。

    public interface Item {
     public String name();
    public Packing packing();
    public float price();    
    }
    
    public interface Packing {
     public String pack();
    }
创建实现 Packing 接口的实体类。
包装纸
        
        public class Wrapper implements Packing {
            @Override
            public String pack() {
            return "Wrapper";
            }
        }
瓶子

    public class Bottle implements Packing {
        @Override
        public String pack() {
        return "Bottle";
        }
    }

    public abstract class Burger implements Item {
 
       @Override
       public Packing packing() {
          return new Wrapper();
       }

       @Override
       public abstract float price();
    }
    
    public abstract class ColdDrink implements Item {
 
    @Override
    public Packing packing() {
       return new Bottle();
    }
 
    @Override
    public abstract float price();
    }
    
    public class VegBurger extends Burger {
 
       @Override
       public float price() {
          return 25.0f;
       }

       @Override
       public String name() {
          return "Veg Burger";
       }
    }
    
    public class ChickenBurger extends Burger {
 
       @Override
       public float price() {
          return 50.5f;
       }

       @Override
       public String name() {
          return "Chicken Burger";
       }
    }
    
    public class Coke extends ColdDrink {
 
       @Override
       public float price() {
          return 30.0f;
       }

       @Override
       public String name() {
          return "Coke";
       }
    }
    
    public class Pepsi extends ColdDrink {
 
       @Override
       public float price() {
          return 35.0f;
       }

       @Override
       public String name() {
          return "Pepsi";
       }
    }
    
创建一个 Meal 类，带有上面定义的 Item 对象。

    import java.util.ArrayList;
    import java.util.List;

    public class Meal {
       private List<Item> items = new ArrayList<Item>();    

       public void addItem(Item item){
          items.add(item);
       }

       public float getCost(){
          float cost = 0.0f;
          for (Item item : items) {
             cost += item.price();
          }        
          return cost;
       }

       public void showItems(){
          for (Item item : items) {
             System.out.print("Item : "+item.name());
             System.out.print(", Packing : "+item.packing().pack());
             System.out.println(", Price : "+item.price());
          }        
       }    
    }
 创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。
 
    public class MealBuilder {

       public Meal prepareVegMeal (){
          Meal meal = new Meal();
          meal.addItem(new VegBurger());
          meal.addItem(new Coke());
          return meal;
       }   

       public Meal prepareNonVegMeal (){
          Meal meal = new Meal();
          meal.addItem(new ChickenBurger());
          meal.addItem(new Pepsi());
          return meal;
       }
    }

BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。

    public class BuilderPatternDemo {
        public static void main(String[] args) {
            MealBuilder mealBuilder = new MealBuilder();
 
            Meal vegMeal = mealBuilder.prepareVegMeal();
            System.out.println("Veg Meal");
            vegMeal.showItems();
            System.out.println("Total Cost: " +vegMeal.getCost());
 
            Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
            System.out.println("\n\nNon-Veg Meal");
            nonVegMeal.showItems();
            System.out.println("Total Cost: " +nonVegMeal.getCost());
        }
    }
执行程序，输出结果：

        Veg Meal
        Item : Veg Burger, Packing : Wrapper, Price : 25.0
        Item : Coke, Packing : Bottle, Price : 30.0
        Total Cost: 55.0


        Non-Veg Meal
        Item : Chicken Burger, Packing : Wrapper, Price : 50.5
        Item : Pepsi, Packing : Bottle, Price : 35.0
        Total Cost: 85.5
6.代理模式（Proxy Pattern）
----
抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。
代理模式的实现

    package proxy;
    public class ProxyTest
    {
        public static void main(String[] args)
        {
            Proxy proxy=new Proxy();
            proxy.Request();
        }
    }
    //抽象主题
    interface Subject
    {
        void Request();
    }
    //真实主题
    class RealSubject implements Subject
    {
        public void Request()
        {
            System.out.println("访问真实主题方法...");
        }
    }
    //代理
    class Proxy implements Subject
    {
        private RealSubject realSubject;
        public void Request()
        {
            if (realSubject==null)
            {
                realSubject=new RealSubject();
            }
            preRequest();
            realSubject.Request();
            postRequest();
        }
        public void preRequest()
        {
            System.out.println("访问真实主题之前的预处理。");
        }
        public void postRequest()
        {
            System.out.println("访问真实主题之后的后续处理。");
        }
    }

7.适配器模式（Adapter Pattern）
----
在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。

在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。

适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

该模式的主要优点如下。 
客户端通过适配器可以透明地调用目标接口。
复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。

其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。
类适配器模式代码如下

    package adapter;
    //目标接口
    interface Target
    {
        public void request();
    }
    //适配者接口
    class Adaptee
    {
        public void specificRequest()
        {       
            System.out.println("适配者中的业务代码被调用！");
        }
    }
    //类适配器类
    class ClassAdapter extends Adaptee implements Target
    {
        public void request()
        {
            specificRequest();
        }
    }
    //客户端代码
    public class ClassAdapterTest
    {
        public static void main(String[] args)
        {
            System.out.println("类适配器模式测试：");
            Target target = new ClassAdapter();
            target.request();
        }
    }
    
对象适配器模式的代码如下

    package adapter;
    //对象适配器类
    class ObjectAdapter implements Target
    {
        private Adaptee adaptee;
        public ObjectAdapter(Adaptee adaptee)
        {
            this.adaptee=adaptee;
        }
        public void request()
        {
            adaptee.specificRequest();
        }
    }
    //客户端代码
    public class ObjectAdapterTest
    {
        public static void main(String[] args)
        {
            System.out.println("对象适配器模式测试：");
            Adaptee adaptee = new Adaptee();
            Target target = new ObjectAdapter(adaptee);
            target.request();
        }
    }

8.桥接模式
-----
桥接（Bridge）模式包含以下主要角色。 
抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。
扩展抽象化（Refined    Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。
具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。

桥接模式代码如下

        package bridge;
        public class BridgeTest
        {
            public static void main(String[] args)
            {
                Implementor imple=new ConcreteImplementorA();
                Abstraction abs=new RefinedAbstraction(imple);
                abs.Operation();
            }
        }
        //实现化角色
        interface Implementor
        {
            public void OperationImpl();
        }
        //具体实现化角色
        class ConcreteImplementorA implements Implementor
        {
            public void OperationImpl()
            {
                System.out.println("具体实现化(Concrete Implementor)角色被访问" );
            }
        }
        //抽象化角色
        abstract class Abstraction
        {
           protected Implementor imple;
           protected Abstraction(Implementor imple)
           {
               this.imple=imple;
           }
           public abstract void Operation();   
        }
        //扩展抽象化角色
        class RefinedAbstraction extends Abstraction
        {
           protected RefinedAbstraction(Implementor imple)
           {
               super(imple);
           }
           public void Operation()
           {
               System.out.println("扩展抽象化(Refined Abstraction)角色被访问" );
               imple.OperationImpl();
           }
        }


9.装饰模式（Decorator Pattern）
-------
装饰（Decorator）模式的主要优点有： 
采用装饰模式扩展对象的功能比采用继承方式更加灵活。
可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。

装饰模式主要包含以下角色。 
抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
具体构件（Concrete    Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。
抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

装饰模式的实现代码如下： 

    package decorator;
    public class DecoratorPattern
    {
        public static void main(String[] args)
        {
            Component p=new ConcreteComponent();
            p.operation();
            System.out.println("---------------------------------");
            Component d=new ConcreteDecorator(p);
            d.operation();
        }
    }
    //抽象构件角色
    interface  Component
    {
        public void operation();
    }
    //具体构件角色
    class ConcreteComponent implements Component
    {
        public ConcreteComponent()
        {
            System.out.println("创建具体构件角色");       
        }   
        public void operation()
        {
            System.out.println("调用具体构件角色的方法operation()");           
        }
    }
    //抽象装饰角色
    class Decorator implements Component
    {
        private Component component;   
        public Decorator(Component component)
        {
            this.component=component;
        }   
        public void operation()
        {
            component.operation();
        }
    }
    //具体装饰角色
    class ConcreteDecorator extends Decorator
    {
        public ConcreteDecorator(Component component)
        {
            super(component);
        }   
        public void operation()
        {
            super.operation();
            addedFunction();
        }
        public void addedFunction()
        {
            System.out.println("为具体构件角色增加额外的功能addedFunction()");           
        }
    }
    

10.外观模式
-------
外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

    public interface Shape {
    void draw();
    }

    public class Rectangle implements Shape {

       @Override
       public void draw() {
          System.out.println("Rectangle::draw()");
       }
    }
    
    public class Square implements Shape {
 
       @Override
       public void draw() {
          System.out.println("Square::draw()");
       }
    }
    
    public class Circle implements Shape {
 
       @Override
       public void draw() {
          System.out.println("Circle::draw()");
       }
    }
    
创建一个外观类

       public class ShapeMaker {
       private Shape circle;
       private Shape rectangle;
       private Shape square;

       public ShapeMaker() {
          circle = new Circle();
          rectangle = new Rectangle();
          square = new Square();
       }

       public void drawCircle(){
          circle.draw();
       }
       public void drawRectangle(){
          rectangle.draw();
       }
       public void drawSquare(){
          square.draw();
       }
       }
       
    public class FacadePatternDemo {
    public static void main(String[] args) {
    ShapeMaker shapeMaker = new ShapeMaker();
      shapeMaker.drawCircle();
      shapeMaker.drawRectangle();
      shapeMaker.drawSquare();      
     }
    }   
 
11.享元模式
-------
享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。
关键代码：用 HashMap 存储这些对象。

创建一个接口。

    public interface Shape {
       void draw();
    }
    
创建实现接口的实体类。

    public class Circle implements Shape {
       private String color;
       private int x;
       private int y;
       private int radius;

       public Circle(String color){
          this.color = color;     
       }

       public void setX(int x) {
          this.x = x;
       }

       public void setY(int y) {
          this.y = y;
       }

       public void setRadius(int radius) {
          this.radius = radius;
       }

       @Override
       public void draw() {
          System.out.println("Circle: Draw() [Color : " + color 
             +", x : " + x +", y :" + y +", radius :" + radius);
       }
     }

创建一个工厂，生成基于给定信息的实体类的对象。

    import java.util.HashMap;
 
    public class ShapeFactory {
       private static final HashMap<String, Shape> circleMap = new HashMap<>();

       public static Shape getCircle(String color) {
          Circle circle = (Circle)circleMap.get(color);

          if(circle == null) {
             circle = new Circle(color);
             circleMap.put(color, circle);
             System.out.println("Creating circle of color : " + color);
          }
          return circle;
       }
    }
    
使用该工厂，通过传递颜色信息来获取实体类的对象。

    public class FlyweightPatternDemo {
       private static final String colors[] = 
          { "Red", "Green", "Blue", "White", "Black" };
       public static void main(String[] args) {

          for(int i=0; i < 20; ++i) {
             Circle circle = 
                (Circle)ShapeFactory.getCircle(getRandomColor());
             circle.setX(getRandomX());
             circle.setY(getRandomY());
             circle.setRadius(100);
             circle.draw();
          }
       }
       private static String getRandomColor() {
          return colors[(int)(Math.random()*colors.length)];
       }
       private static int getRandomX() {
          return (int)(Math.random()*100 );
       }
       private static int getRandomY() {
          return (int)(Math.random()*100);
       }
    }


12.组合模式
-------
组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。

    import java.util.ArrayList;
    import java.util.List;

    public class Employee {
       private String name;
       private String dept;
       private int salary;
       private List<Employee> subordinates;

       //构造函数
       public Employee(String name,String dept, int sal) {
          this.name = name;
          this.dept = dept;
          this.salary = sal;
          subordinates = new ArrayList<Employee>();
       }

       public void add(Employee e) {
          subordinates.add(e);
       }

       public void remove(Employee e) {
          subordinates.remove(e);
       }

       public List<Employee> getSubordinates(){
         return subordinates;
       }

       public String toString(){
          return ("Employee :[ Name : "+ name 
          +", dept : "+ dept + ", salary :"
          + salary+" ]");
       }   
    }
    
    public class CompositePatternDemo {
    public static void main(String[] args) {
      Employee CEO = new Employee("John","CEO", 30000);
 
      Employee headSales = new Employee("Robert","Head Sales", 20000);
 
      Employee headMarketing = new Employee("Michel","Head Marketing", 20000);
 
      Employee clerk1 = new Employee("Laura","Marketing", 10000);
      Employee clerk2 = new Employee("Bob","Marketing", 10000);
 
      Employee salesExecutive1 = new Employee("Richard","Sales", 10000);
      Employee salesExecutive2 = new Employee("Rob","Sales", 10000);
 
      CEO.add(headSales);
      CEO.add(headMarketing);
 
      headSales.add(salesExecutive1);
      headSales.add(salesExecutive2);
 
      headMarketing.add(clerk1);
      headMarketing.add(clerk2);
 
      //打印该组织的所有员工
      System.out.println(CEO); 
      for (Employee headEmployee : CEO.getSubordinates()) {
         System.out.println(headEmployee);
         for (Employee employee : headEmployee.getSubordinates()) {
            System.out.println(employee);
         }
      }        
    }
    }
 


13.模板方法模式
-------
模板方法（Template Method）模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。

该模式的主要优点如下。
它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。
它在父类中提取了公共的部分代码，便于代码复用。
部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。

该模式的主要缺点如下。
对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。
父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。
模板方法模式的代码如下：

    package templateMethod;
    public class TemplateMethodPattern
    {
        public static void main(String[] args)
        {
            AbstractClass tm=new ConcreteClass();
            tm.TemplateMethod();
        }
    }
    //抽象类
    abstract class AbstractClass
    {
        public void TemplateMethod() //模板方法
        {
            SpecificMethod();
            abstractMethod1();          
             abstractMethod2();
        }  
        public void SpecificMethod() //具体方法
        {
            System.out.println("抽象类中的具体方法被调用...");
        }   
        public abstract void abstractMethod1(); //抽象方法1
        public abstract void abstractMethod2(); //抽象方法2
    }
    //具体子类
    class ConcreteClass extends AbstractClass
    {
        public void abstractMethod1()
        {
            System.out.println("抽象方法1的实现被调用...");
        }   
        public void abstractMethod2()
        {
            System.out.println("抽象方法2的实现被调用...");
        }
    }


14.策略模式（Strategy Pattern）
------
策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。

策略模式的主要优点如下。
多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。
策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。
策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。
策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。
策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。

其主要缺点如下。
客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
策略模式造成很多的策略类。

    package strategy;
    public class StrategyPattern
    {
        public static void main(String[] args)
        {
            Context c=new Context();
            Strategy s=new ConcreteStrategyA();
            c.setStrategy(s);
            c.strategyMethod();
            System.out.println("-----------------");
            s=new ConcreteStrategyB();
            c.setStrategy(s);
            c.strategyMethod();
        }
    }
    //抽象策略类
    interface Strategy
    {   
        public void strategyMethod();    //策略方法
    }
    //具体策略类A
    class ConcreteStrategyA implements Strategy
    {
        public void strategyMethod()
        {
            System.out.println("具体策略A的策略方法被访问！");
        }
    }
    //具体策略类B
    class ConcreteStrategyB implements Strategy
    {
      public void strategyMethod()
      {
          System.out.println("具体策略B的策略方法被访问！");
      }
    }
    //环境类
    class Context
    {
        private Strategy strategy;
        public Strategy getStrategy()
        {
            return strategy;
        }
        public void setStrategy(Strategy strategy)
        {
            this.strategy=strategy;
        }
        public void strategyMethod()
        {
            strategy.strategyMethod();
        }
    }

读java 8 in action lambda表达式相关
行为参数化，通过定义一个接口来对选择标准建模，比如说:

    public inteface applePrediect{
     boolean test(Apple apple);
    }

可以用不同的实现来代表不同的选择标准,比如:

    public class AppleHeavyWeightPredicate implements ApplePredicate{
      public boolean test(Apple apple){
        return apple.getWeight() > 150;
      } 
    } 

    public class AppleGreenColorPredicate implements ApplePredicate{
      public boolean test(Apple apple){
        return "green".equals(apple.getColor());
      } 
    }

你可以把这些标准看作filter方法的不同行为。你刚做的这些和“策略设计模式”①相关， 它让你定义一族算法，把它们封装起来（称为“策略”），然后在运行时选择一个算法。
在这里， 算法族就是ApplePredicate，不同的策略就是AppleHeavyWeightPredicate和AppleGreen- ColorPredicate。 但是，该怎么利用ApplePredicate的不同实现呢？
你需要filterApples方法接受 ApplePredicate对象，对Apple做条件测试。这就是行为参数化：让方法接受多种行为（或战 略）作为参数，并在内部使用，来完成不同的行为。
要在我们的例子中实现这一点，你要给filterApples方法添加一个参数，让它接受 ApplePredicate对象。这在软件工程上有很大好处：现在你把filterApples方法迭代集合的
逻辑与你要应用到集合中每个元素的行为（这里是一个谓词）区分开了。 
利用ApplePredicate改过之后，filter方法看起来是这样的： 

    public static List<Apple> filterApples(List<Apple> inventory,ApplePredicate p){ 
      List<Apple> result = new ArrayList<>(); 
        for(Apple apple: inventory){ 
          if(p.test(apple)){  
            result.add(apple);  
          }  
        } 
      return result; 
    } 
找出所有重量超过150克的红苹果，你只需要创建一 个类来实现ApplePredicate就行了。
    
    public class AppleRedAndHeavyPredicate implements ApplePredicate{
      public boolean test(Apple apple){
      return "red".equals(apple.getColor()) && apple.getWeight() > 150;
      } 
     } 
    List<Apple> redAndHeavyApples = filterApples(inventory, new AppleRedAndHeavyPredicate()); 
但令人遗憾的是，由于该filterApples方法只能接受对象， 所以你必须把代码包裹在ApplePredicate对象里。你的做法就类似于在内联“传递代码”，因 为你是通过一个实现了test方法的对象来传递布尔表达式的。通过使用Lambda，你可以直接把表达式"red".equals(apple.getColor()) &&apple.getWeight() > 150传递给filterApples方法，而无需定义多个ApplePredicate 类，从而去掉不必要的代码。
匿名内部类也可以实现。
但匿名类还是不够好。第一，它往往很笨重，因为它占用了很多空间。还拿前面的例子来看，如下面代码所示：

    List<Apple> redApples = filterApples(inventory, new ApplePredicate() {
      public boolean test(Apple a){  
        return "red".equals(a.getColor()); 
        } 
       }); 
Java FX API
    
    button.setOnAction(new EventHandler<ActionEvent>() { 
      public void handle(ActionEvent event) { 
        System.out.println("Woooo a click!!");
      } 
    }); 
第二，很多程序员觉得它用起来很让人费解。
使用lambda表达式
    
    List<Apple> redApples = filterApples(inventory,(Apple apple) -> "red".equals(apple.getColor()));
15.命令模式
--------
命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。

命令模式的主要优点如下。
降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。
增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。
可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。
方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。

其缺点是：可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。

    package command;
    public class CommandPattern
    {
        public static void main(String[] args)
        {
            Command cmd=new ConcreteCommand();
            Invoker ir=new Invoker(cmd);
            System.out.println("客户访问调用者的call()方法...");
            ir.call();
        }
    }
    //调用者
    class Invoker
    {
        private Command command;
        public Invoker(Command command)
        {
            this.command=command;
        }
        public void setCommand(Command command)
        {
            this.command=command;
        }
        public void call()
        {
            System.out.println("调用者执行命令command...");
            command.execute();
        }
    }
    //抽象命令
    interface Command
    {
        public abstract void execute();
    }
    //具体命令
    class ConcreteCommand implements Command
    {
        private Receiver receiver;
        ConcreteCommand()
        {
            receiver=new Receiver();
        }
        public void execute()
        {
            receiver.action();
        }
    }
    //接收者
    class Receiver
    {
        public void action()
        {
            System.out.println("接收者的action()方法被调用...");
        }
    }

16.责任链模式
--------
责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。

责任链模式是一种对象行为型模式，其主要优点如下。
降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。
增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。
增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。
责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。
责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。

其主要缺点如下。
不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。
对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。
职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。

职责链模式主要包含以下角色。
抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。

    package chainOfResponsibility;
    public class ChainOfResponsibilityPattern
    {
        public static void main(String[] args)
        {
            //组装责任链 
            Handler handler1=new ConcreteHandler1(); 
            Handler handler2=new ConcreteHandler2(); 
            handler1.setNext(handler2); 
            //提交请求 
            handler1.handleRequest("two");
        }
    }
    //抽象处理者角色
    abstract class Handler
    {
        private Handler next;
        public void setNext(Handler next)
        {
            this.next=next; 
        }
        public Handler getNext()
        { 
            return next; 
        }   
        //处理请求的方法
        public abstract void handleRequest(String request);       
    }
    //具体处理者角色1
    class ConcreteHandler1 extends Handler
    {
        public void handleRequest(String request)
        {
            if(request.equals("one")) 
            {
                System.out.println("具体处理者1负责处理该请求！");       
            }
            else
            {
                if(getNext()!=null) 
                {
                    getNext().handleRequest(request);             
                }
                else
                {
                    System.out.println("没有人处理该请求！");
                }
            } 
        } 
    }
    //具体处理者角色2
    class ConcreteHandler2 extends Handler
    {
        public void handleRequest(String request)
        {
            if(request.equals("two")) 
            {
                System.out.println("具体处理者2负责处理该请求！");       
            }
            else
            {
                if(getNext()!=null) 
                {
                    getNext().handleRequest(request);             
                }
                else
                {
                    System.out.println("没有人处理该请求！");
                }
            } 
        }
    }

17.状态模式
---------

18.观察者模式
---------

19.中介者模式
---------

20.迭代器模式
---------

21.访问者模式
----------

22.备忘录模式
----------

23.解释器模式
----------

