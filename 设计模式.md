23种设计模式
======
设计模式按类型分为创建型、结构型、行为型模式。

1.单例模式（Singleton Pattern）
-----
6种

1.1懒汉式 线程不安全
是否 Lazy 初始化：是
是否多线程安全：否
实现难度：易
    
    public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
  
    public static Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
    }
1.2懒汉式 线程安全
是否 Lazy 初始化：是
是否多线程安全：是
实现难度：易

    public class Singleton {  
        private static Singleton instance;  
        private Singleton (){}  
        public static synchronized Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
        }  
    }
 1.3饿汉式
是否 Lazy 初始化：否
是否多线程安全：是
实现难度：易

    public class Singleton {  
        private static Singleton instance = new Singleton();  
        private Singleton (){}  
        public static Singleton getInstance() {  
        return instance;  
        }  
    }
1.4双检锁/双重校验锁（DCL，即 double-checked locking）
JDK 版本：JDK1.5 起
是否 Lazy 初始化：是
是否多线程安全：是

    public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
    }
1.5静态内部类
是否 Lazy 初始化：是
是否多线程安全：是

    public class Singleton {  
        private static class SingletonHolder {  
        private static final Singleton INSTANCE = new Singleton();  
        }  
        private Singleton (){}  
        public static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE;  
        }  
    }
1.6枚举
JDK 版本：JDK1.5 起。这是实现单例模式的最佳方法，Effective Java 作者 Josh Bloch 提倡的方式，支持序列化机制，绝对防止多次实例化。
是否 Lazy 初始化：否
是否多线程安全：是

    public enum Singleton {  
        INSTANCE;  
        public void whateverMethod() {  
        }  
    }
经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。

2.工厂模式
-------
在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。


    public interface Shape {
    void draw();
    }
    public class Rectangle implements Shape {
        @Override
        public void draw() {
        System.out.println("Inside Rectangle::draw() method.");
        }
    }
    public class Square implements Shape {
        @Override
        public void draw() {
            System.out.println("Inside Square::draw() method.");
        }
    }
    public class Circle implements Shape {
        @Override
        public void draw() {
        System.out.println("Inside Circle::draw() method.");
    }
    }
    public class ShapeFactory {
    
    //使用 getShape 方法获取形状类型的对象
    public Shape getShape(String shapeType){
        if(shapeType == null){
            return null;
        }        
        if(shapeType.equalsIgnoreCase("CIRCLE")){
            return new Circle();
        } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
            return new Rectangle();
        } else if(shapeType.equalsIgnoreCase("SQUARE")){
             return new Square();
        }
          return null;
    }
    }

3.抽象工厂模式（Abstract Factory Pattern）
-----
抽象工厂：提供了产品的生成方法。

    interface AbstractFactory
    {
    public Product1 newProduct1();
    public Product2 newProduct2();
    }
具体工厂：实现了产品的生成方法。

    class ConcreteFactory1 implements AbstractFactory
    {
    public Product1 newProduct1()
    {
        System.out.println("具体工厂 1 生成-->具体产品 11...");
        return new ConcreteProduct11();
    }
    public Product2 newProduct2()
    {
        System.out.println("具体工厂 1 生成-->具体产品 21...");
        return new ConcreteProduct21();
    }
    }
    

4.原型模式（Prototype Pattern）
-------
何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。 
深拷贝代码如下

        public Shape deepClone() throws IOException,ClassNotFoundException{
        //将对象写入流中
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
        objectOutputStream.writeObject(this);
        //从流中取出
        ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
        return (Shape)objectInputStream.readObject();
        }

5.建造者模式（Builder Pattern）
--------

我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。
我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。
然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。

![image](https://github.com/undefiersun/java-note/blob/master/images/builder_pattern_uml_diagram.jpg)

创建一个表示食物条目和食物包装的接口。

    public interface Item {
     public String name();
    public Packing packing();
    public float price();    
    }
    
    public interface Packing {
     public String pack();
    }
创建实现 Packing 接口的实体类。
包装纸
        
        public class Wrapper implements Packing {
            @Override
            public String pack() {
            return "Wrapper";
            }
        }
瓶子

    public class Bottle implements Packing {
        @Override
        public String pack() {
        return "Bottle";
        }
    }

    public abstract class Burger implements Item {
 
       @Override
       public Packing packing() {
          return new Wrapper();
       }

       @Override
       public abstract float price();
    }
    
    public abstract class ColdDrink implements Item {
 
    @Override
    public Packing packing() {
       return new Bottle();
    }
 
    @Override
    public abstract float price();
    }
    
    public class VegBurger extends Burger {
 
       @Override
       public float price() {
          return 25.0f;
       }

       @Override
       public String name() {
          return "Veg Burger";
       }
    }
    
    public class ChickenBurger extends Burger {
 
       @Override
       public float price() {
          return 50.5f;
       }

       @Override
       public String name() {
          return "Chicken Burger";
       }
    }
    
    public class Coke extends ColdDrink {
 
       @Override
       public float price() {
          return 30.0f;
       }

       @Override
       public String name() {
          return "Coke";
       }
    }
    
    public class Pepsi extends ColdDrink {
 
       @Override
       public float price() {
          return 35.0f;
       }

       @Override
       public String name() {
          return "Pepsi";
       }
    }
    
创建一个 Meal 类，带有上面定义的 Item 对象。

    import java.util.ArrayList;
    import java.util.List;

    public class Meal {
       private List<Item> items = new ArrayList<Item>();    

       public void addItem(Item item){
          items.add(item);
       }

       public float getCost(){
          float cost = 0.0f;
          for (Item item : items) {
             cost += item.price();
          }        
          return cost;
       }

       public void showItems(){
          for (Item item : items) {
             System.out.print("Item : "+item.name());
             System.out.print(", Packing : "+item.packing().pack());
             System.out.println(", Price : "+item.price());
          }        
       }    
    }
 创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。
 
    public class MealBuilder {

       public Meal prepareVegMeal (){
          Meal meal = new Meal();
          meal.addItem(new VegBurger());
          meal.addItem(new Coke());
          return meal;
       }   

       public Meal prepareNonVegMeal (){
          Meal meal = new Meal();
          meal.addItem(new ChickenBurger());
          meal.addItem(new Pepsi());
          return meal;
       }
    }

BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。

    public class BuilderPatternDemo {
        public static void main(String[] args) {
            MealBuilder mealBuilder = new MealBuilder();
 
            Meal vegMeal = mealBuilder.prepareVegMeal();
            System.out.println("Veg Meal");
            vegMeal.showItems();
            System.out.println("Total Cost: " +vegMeal.getCost());
 
            Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
            System.out.println("\n\nNon-Veg Meal");
            nonVegMeal.showItems();
            System.out.println("Total Cost: " +nonVegMeal.getCost());
        }
    }
执行程序，输出结果：

        Veg Meal
        Item : Veg Burger, Packing : Wrapper, Price : 25.0
        Item : Coke, Packing : Bottle, Price : 30.0
        Total Cost: 55.0


        Non-Veg Meal
        Item : Chicken Burger, Packing : Wrapper, Price : 50.5
        Item : Pepsi, Packing : Bottle, Price : 35.0
        Total Cost: 85.5
6.代理模式（Proxy Pattern）
----
抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。
代理模式的实现

    package proxy;
    public class ProxyTest
    {
        public static void main(String[] args)
        {
            Proxy proxy=new Proxy();
            proxy.Request();
        }
    }
    //抽象主题
    interface Subject
    {
        void Request();
    }
    //真实主题
    class RealSubject implements Subject
    {
        public void Request()
        {
            System.out.println("访问真实主题方法...");
        }
    }
    //代理
    class Proxy implements Subject
    {
        private RealSubject realSubject;
        public void Request()
        {
            if (realSubject==null)
            {
                realSubject=new RealSubject();
            }
            preRequest();
            realSubject.Request();
            postRequest();
        }
        public void preRequest()
        {
            System.out.println("访问真实主题之前的预处理。");
        }
        public void postRequest()
        {
            System.out.println("访问真实主题之后的后续处理。");
        }
    }

7.适配器模式（Adapter Pattern）
----
在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。

在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。

适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

该模式的主要优点如下。 
客户端通过适配器可以透明地调用目标接口。
复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。

其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。
类适配器模式代码如下

    package adapter;
    //目标接口
    interface Target
    {
        public void request();
    }
    //适配者接口
    class Adaptee
    {
        public void specificRequest()
        {       
            System.out.println("适配者中的业务代码被调用！");
        }
    }
    //类适配器类
    class ClassAdapter extends Adaptee implements Target
    {
        public void request()
        {
            specificRequest();
        }
    }
    //客户端代码
    public class ClassAdapterTest
    {
        public static void main(String[] args)
        {
            System.out.println("类适配器模式测试：");
            Target target = new ClassAdapter();
            target.request();
        }
    }
    
对象适配器模式的代码如下

    package adapter;
    //对象适配器类
    class ObjectAdapter implements Target
    {
        private Adaptee adaptee;
        public ObjectAdapter(Adaptee adaptee)
        {
            this.adaptee=adaptee;
        }
        public void request()
        {
            adaptee.specificRequest();
        }
    }
    //客户端代码
    public class ObjectAdapterTest
    {
        public static void main(String[] args)
        {
            System.out.println("对象适配器模式测试：");
            Adaptee adaptee = new Adaptee();
            Target target = new ObjectAdapter(adaptee);
            target.request();
        }
    }

8.桥接模式
-----
桥接（Bridge）模式包含以下主要角色。 
抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。
扩展抽象化（Refined    Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。
具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。

桥接模式代码如下

        package bridge;
        public class BridgeTest
        {
            public static void main(String[] args)
            {
                Implementor imple=new ConcreteImplementorA();
                Abstraction abs=new RefinedAbstraction(imple);
                abs.Operation();
            }
        }
        //实现化角色
        interface Implementor
        {
            public void OperationImpl();
        }
        //具体实现化角色
        class ConcreteImplementorA implements Implementor
        {
            public void OperationImpl()
            {
                System.out.println("具体实现化(Concrete Implementor)角色被访问" );
            }
        }
        //抽象化角色
        abstract class Abstraction
        {
           protected Implementor imple;
           protected Abstraction(Implementor imple)
           {
               this.imple=imple;
           }
           public abstract void Operation();   
        }
        //扩展抽象化角色
        class RefinedAbstraction extends Abstraction
        {
           protected RefinedAbstraction(Implementor imple)
           {
               super(imple);
           }
           public void Operation()
           {
               System.out.println("扩展抽象化(Refined Abstraction)角色被访问" );
               imple.OperationImpl();
           }
        }


9.装饰模式（Decorator Pattern）
-------
装饰（Decorator）模式的主要优点有： 
采用装饰模式扩展对象的功能比采用继承方式更加灵活。
可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。

装饰模式主要包含以下角色。 
抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
具体构件（Concrete    Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。
抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

装饰模式的实现代码如下： 

    package decorator;
    public class DecoratorPattern
    {
        public static void main(String[] args)
        {
            Component p=new ConcreteComponent();
            p.operation();
            System.out.println("---------------------------------");
            Component d=new ConcreteDecorator(p);
            d.operation();
        }
    }
    //抽象构件角色
    interface  Component
    {
        public void operation();
    }
    //具体构件角色
    class ConcreteComponent implements Component
    {
        public ConcreteComponent()
        {
            System.out.println("创建具体构件角色");       
        }   
        public void operation()
        {
            System.out.println("调用具体构件角色的方法operation()");           
        }
    }
    //抽象装饰角色
    class Decorator implements Component
    {
        private Component component;   
        public Decorator(Component component)
        {
            this.component=component;
        }   
        public void operation()
        {
            component.operation();
        }
    }
    //具体装饰角色
    class ConcreteDecorator extends Decorator
    {
        public ConcreteDecorator(Component component)
        {
            super(component);
        }   
        public void operation()
        {
            super.operation();
            addedFunction();
        }
        public void addedFunction()
        {
            System.out.println("为具体构件角色增加额外的功能addedFunction()");           
        }
    }
    

10.外观模式
-------
外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

    public interface Shape {
    void draw();
    }

    public class Rectangle implements Shape {

       @Override
       public void draw() {
          System.out.println("Rectangle::draw()");
       }
    }
    
    public class Square implements Shape {
 
       @Override
       public void draw() {
          System.out.println("Square::draw()");
       }
    }
    
    public class Circle implements Shape {
 
       @Override
       public void draw() {
          System.out.println("Circle::draw()");
       }
    }
    
创建一个外观类

       public class ShapeMaker {
       private Shape circle;
       private Shape rectangle;
       private Shape square;

       public ShapeMaker() {
          circle = new Circle();
          rectangle = new Rectangle();
          square = new Square();
       }

       public void drawCircle(){
          circle.draw();
       }
       public void drawRectangle(){
          rectangle.draw();
       }
       public void drawSquare(){
          square.draw();
       }
       }
       
    public class FacadePatternDemo {
    public static void main(String[] args) {
    ShapeMaker shapeMaker = new ShapeMaker();
      shapeMaker.drawCircle();
      shapeMaker.drawRectangle();
      shapeMaker.drawSquare();      
     }
    }   
 
11.享元模式
-------
享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。
关键代码：用 HashMap 存储这些对象。

创建一个接口。

    public interface Shape {
       void draw();
    }
    
创建实现接口的实体类。

    public class Circle implements Shape {
       private String color;
       private int x;
       private int y;
       private int radius;

       public Circle(String color){
          this.color = color;     
       }

       public void setX(int x) {
          this.x = x;
       }

       public void setY(int y) {
          this.y = y;
       }

       public void setRadius(int radius) {
          this.radius = radius;
       }

       @Override
       public void draw() {
          System.out.println("Circle: Draw() [Color : " + color 
             +", x : " + x +", y :" + y +", radius :" + radius);
       }
     }

创建一个工厂，生成基于给定信息的实体类的对象。

    import java.util.HashMap;
 
    public class ShapeFactory {
       private static final HashMap<String, Shape> circleMap = new HashMap<>();

       public static Shape getCircle(String color) {
          Circle circle = (Circle)circleMap.get(color);

          if(circle == null) {
             circle = new Circle(color);
             circleMap.put(color, circle);
             System.out.println("Creating circle of color : " + color);
          }
          return circle;
       }
    }
    
使用该工厂，通过传递颜色信息来获取实体类的对象。

    public class FlyweightPatternDemo {
       private static final String colors[] = 
          { "Red", "Green", "Blue", "White", "Black" };
       public static void main(String[] args) {

          for(int i=0; i < 20; ++i) {
             Circle circle = 
                (Circle)ShapeFactory.getCircle(getRandomColor());
             circle.setX(getRandomX());
             circle.setY(getRandomY());
             circle.setRadius(100);
             circle.draw();
          }
       }
       private static String getRandomColor() {
          return colors[(int)(Math.random()*colors.length)];
       }
       private static int getRandomX() {
          return (int)(Math.random()*100 );
       }
       private static int getRandomY() {
          return (int)(Math.random()*100);
       }
    }


12.组合模式
-------
组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。

    import java.util.ArrayList;
    import java.util.List;

    public class Employee {
       private String name;
       private String dept;
       private int salary;
       private List<Employee> subordinates;

       //构造函数
       public Employee(String name,String dept, int sal) {
          this.name = name;
          this.dept = dept;
          this.salary = sal;
          subordinates = new ArrayList<Employee>();
       }

       public void add(Employee e) {
          subordinates.add(e);
       }

       public void remove(Employee e) {
          subordinates.remove(e);
       }

       public List<Employee> getSubordinates(){
         return subordinates;
       }

       public String toString(){
          return ("Employee :[ Name : "+ name 
          +", dept : "+ dept + ", salary :"
          + salary+" ]");
       }   
    }
    
    public class CompositePatternDemo {
    public static void main(String[] args) {
      Employee CEO = new Employee("John","CEO", 30000);
 
      Employee headSales = new Employee("Robert","Head Sales", 20000);
 
      Employee headMarketing = new Employee("Michel","Head Marketing", 20000);
 
      Employee clerk1 = new Employee("Laura","Marketing", 10000);
      Employee clerk2 = new Employee("Bob","Marketing", 10000);
 
      Employee salesExecutive1 = new Employee("Richard","Sales", 10000);
      Employee salesExecutive2 = new Employee("Rob","Sales", 10000);
 
      CEO.add(headSales);
      CEO.add(headMarketing);
 
      headSales.add(salesExecutive1);
      headSales.add(salesExecutive2);
 
      headMarketing.add(clerk1);
      headMarketing.add(clerk2);
 
      //打印该组织的所有员工
      System.out.println(CEO); 
      for (Employee headEmployee : CEO.getSubordinates()) {
         System.out.println(headEmployee);
         for (Employee employee : headEmployee.getSubordinates()) {
            System.out.println(employee);
         }
      }        
    }
    }
 


13.模板方法模式
-------
模板方法（Template Method）模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。

该模式的主要优点如下。
它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。
它在父类中提取了公共的部分代码，便于代码复用。
部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。

该模式的主要缺点如下。
对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。
父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。
模板方法模式的代码如下：

    package templateMethod;
    public class TemplateMethodPattern
    {
        public static void main(String[] args)
        {
            AbstractClass tm=new ConcreteClass();
            tm.TemplateMethod();
        }
    }
    //抽象类
    abstract class AbstractClass
    {
        public void TemplateMethod() //模板方法
        {
            SpecificMethod();
            abstractMethod1();          
             abstractMethod2();
        }  
        public void SpecificMethod() //具体方法
        {
            System.out.println("抽象类中的具体方法被调用...");
        }   
        public abstract void abstractMethod1(); //抽象方法1
        public abstract void abstractMethod2(); //抽象方法2
    }
    //具体子类
    class ConcreteClass extends AbstractClass
    {
        public void abstractMethod1()
        {
            System.out.println("抽象方法1的实现被调用...");
        }   
        public void abstractMethod2()
        {
            System.out.println("抽象方法2的实现被调用...");
        }
    }


14.策略模式（Strategy Pattern）
------
策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。

策略模式的主要优点如下。
多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。
策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。
策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。
策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。
策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。

其主要缺点如下。
客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
策略模式造成很多的策略类。

    package strategy;
    public class StrategyPattern
    {
        public static void main(String[] args)
        {
            Context c=new Context();
            Strategy s=new ConcreteStrategyA();
            c.setStrategy(s);
            c.strategyMethod();
            System.out.println("-----------------");
            s=new ConcreteStrategyB();
            c.setStrategy(s);
            c.strategyMethod();
        }
    }
    //抽象策略类
    interface Strategy
    {   
        public void strategyMethod();    //策略方法
    }
    //具体策略类A
    class ConcreteStrategyA implements Strategy
    {
        public void strategyMethod()
        {
            System.out.println("具体策略A的策略方法被访问！");
        }
    }
    //具体策略类B
    class ConcreteStrategyB implements Strategy
    {
      public void strategyMethod()
      {
          System.out.println("具体策略B的策略方法被访问！");
      }
    }
    //环境类
    class Context
    {
        private Strategy strategy;
        public Strategy getStrategy()
        {
            return strategy;
        }
        public void setStrategy(Strategy strategy)
        {
            this.strategy=strategy;
        }
        public void strategyMethod()
        {
            strategy.strategyMethod();
        }
    }

读java 8 in action lambda表达式相关
行为参数化，通过定义一个接口来对选择标准建模，比如说:

    public inteface applePrediect{
     boolean test(Apple apple);
    }

可以用不同的实现来代表不同的选择标准,比如:

    public class AppleHeavyWeightPredicate implements ApplePredicate{
      public boolean test(Apple apple){
        return apple.getWeight() > 150;
      } 
    } 

    public class AppleGreenColorPredicate implements ApplePredicate{
      public boolean test(Apple apple){
        return "green".equals(apple.getColor());
      } 
    }

你可以把这些标准看作filter方法的不同行为。你刚做的这些和“策略设计模式”①相关， 它让你定义一族算法，把它们封装起来（称为“策略”），然后在运行时选择一个算法。
在这里， 算法族就是ApplePredicate，不同的策略就是AppleHeavyWeightPredicate和AppleGreen- ColorPredicate。 但是，该怎么利用ApplePredicate的不同实现呢？
你需要filterApples方法接受 ApplePredicate对象，对Apple做条件测试。这就是行为参数化：让方法接受多种行为（或战 略）作为参数，并在内部使用，来完成不同的行为。
要在我们的例子中实现这一点，你要给filterApples方法添加一个参数，让它接受 ApplePredicate对象。这在软件工程上有很大好处：现在你把filterApples方法迭代集合的
逻辑与你要应用到集合中每个元素的行为（这里是一个谓词）区分开了。 
利用ApplePredicate改过之后，filter方法看起来是这样的： 

    public static List<Apple> filterApples(List<Apple> inventory,ApplePredicate p){ 
      List<Apple> result = new ArrayList<>(); 
        for(Apple apple: inventory){ 
          if(p.test(apple)){  
            result.add(apple);  
          }  
        } 
      return result; 
    } 
找出所有重量超过150克的红苹果，你只需要创建一 个类来实现ApplePredicate就行了。
    
    public class AppleRedAndHeavyPredicate implements ApplePredicate{
      public boolean test(Apple apple){
      return "red".equals(apple.getColor()) && apple.getWeight() > 150;
      } 
     } 
    List<Apple> redAndHeavyApples = filterApples(inventory, new AppleRedAndHeavyPredicate()); 
但令人遗憾的是，由于该filterApples方法只能接受对象， 所以你必须把代码包裹在ApplePredicate对象里。你的做法就类似于在内联“传递代码”，因 为你是通过一个实现了test方法的对象来传递布尔表达式的。通过使用Lambda，你可以直接把表达式"red".equals(apple.getColor()) &&apple.getWeight() > 150传递给filterApples方法，而无需定义多个ApplePredicate 类，从而去掉不必要的代码。
匿名内部类也可以实现。
但匿名类还是不够好。第一，它往往很笨重，因为它占用了很多空间。还拿前面的例子来看，如下面代码所示：

    List<Apple> redApples = filterApples(inventory, new ApplePredicate() {
      public boolean test(Apple a){  
        return "red".equals(a.getColor()); 
        } 
       }); 
Java FX API
    
    button.setOnAction(new EventHandler<ActionEvent>() { 
      public void handle(ActionEvent event) { 
        System.out.println("Woooo a click!!");
      } 
    }); 
第二，很多程序员觉得它用起来很让人费解。
使用lambda表达式
    
    List<Apple> redApples = filterApples(inventory,(Apple apple) -> "red".equals(apple.getColor()));
15.命令模式
--------
命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。

命令模式的主要优点如下。
降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。
增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。
可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。
方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。

其缺点是：可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。

    package command;
    public class CommandPattern
    {
        public static void main(String[] args)
        {
            Command cmd=new ConcreteCommand();
            Invoker ir=new Invoker(cmd);
            System.out.println("客户访问调用者的call()方法...");
            ir.call();
        }
    }
    //调用者
    class Invoker
    {
        private Command command;
        public Invoker(Command command)
        {
            this.command=command;
        }
        public void setCommand(Command command)
        {
            this.command=command;
        }
        public void call()
        {
            System.out.println("调用者执行命令command...");
            command.execute();
        }
    }
    //抽象命令
    interface Command
    {
        public abstract void execute();
    }
    //具体命令
    class ConcreteCommand implements Command
    {
        private Receiver receiver;
        ConcreteCommand()
        {
            receiver=new Receiver();
        }
        public void execute()
        {
            receiver.action();
        }
    }
    //接收者
    class Receiver
    {
        public void action()
        {
            System.out.println("接收者的action()方法被调用...");
        }
    }

16.责任链模式
--------
责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。

责任链模式是一种对象行为型模式，其主要优点如下。
降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。
增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。
增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。
责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。
责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。

其主要缺点如下。
不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。
对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。
职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。

职责链模式主要包含以下角色。
抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。

    package chainOfResponsibility;
    public class ChainOfResponsibilityPattern
    {
        public static void main(String[] args)
        {
            //组装责任链 
            Handler handler1=new ConcreteHandler1(); 
            Handler handler2=new ConcreteHandler2(); 
            handler1.setNext(handler2); 
            //提交请求 
            handler1.handleRequest("two");
        }
    }
    //抽象处理者角色
    abstract class Handler
    {
        private Handler next;
        public void setNext(Handler next)
        {
            this.next=next; 
        }
        public Handler getNext()
        { 
            return next; 
        }   
        //处理请求的方法
        public abstract void handleRequest(String request);       
    }
    //具体处理者角色1
    class ConcreteHandler1 extends Handler
    {
        public void handleRequest(String request)
        {
            if(request.equals("one")) 
            {
                System.out.println("具体处理者1负责处理该请求！");       
            }
            else
            {
                if(getNext()!=null) 
                {
                    getNext().handleRequest(request);             
                }
                else
                {
                    System.out.println("没有人处理该请求！");
                }
            } 
        } 
    }
    //具体处理者角色2
    class ConcreteHandler2 extends Handler
    {
        public void handleRequest(String request)
        {
            if(request.equals("two")) 
            {
                System.out.println("具体处理者2负责处理该请求！");       
            }
            else
            {
                if(getNext()!=null) 
                {
                    getNext().handleRequest(request);             
                }
                else
                {
                    System.out.println("没有人处理该请求！");
                }
            } 
        }
    }

17.状态模式
---------
状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。

状态模式是一种对象行为型模式，其主要优点如下。
状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。
减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。
有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。

状态模式的主要缺点如下。
状态模式的使用必然会增加系统的类与对象的个数。
状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。

    package state;
    public class StatePatternClient
    {
        public static void main(String[] args)
        {       
            Context context=new Context();    //创建环境       
            context.Handle();    //处理请求
            context.Handle();
            context.Handle();
            context.Handle();
        }
    }
    //环境类
    class Context
    {
        private State state;
        //定义环境类的初始状态
        public Context()
        {
            this.state=new ConcreteStateA();
        }
        //设置新状态
        public void setState(State state)
        {
            this.state=state;
        }
        //读取状态
        public State getState()
        {
            return(state);
        }
        //对请求做处理
        public void Handle()
        {
            state.Handle(this);
        }
    }
    //抽象状态类
    abstract class State
    {
        public abstract void Handle(Context context);
    }
    //具体状态A类
    class ConcreteStateA extends State
    {
        public void Handle(Context context)
        {
            System.out.println("当前状态是 A.");
            context.setState(new ConcreteStateB());
        }
    }
    //具体状态B类
    class ConcreteStateB extends State
    {
        public void Handle(Context context)
        {
            System.out.println("当前状态是 B.");
            context.setState(new ConcreteStateA());
        }
    }


18.观察者模式（Observer）
---------
观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。

观察者模式是一种对象行为型模式，其主要优点如下。
降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。
目标与观察者之间建立了一套触发机制。

它的主要缺点如下。
目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。
当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。

    package observer;
    import java.util.*;
    public class ObserverPattern
    {
        public static void main(String[] args)
        {
            Subject subject=new ConcreteSubject();
            Observer obs1=new ConcreteObserver1();
            Observer obs2=new ConcreteObserver2();
            subject.add(obs1);
            subject.add(obs2);
            subject.notifyObserver();
        }
    }
    //抽象目标
    abstract class Subject
    {
        protected List<Observer> observers=new ArrayList<Observer>();   
        //增加观察者方法
        public void add(Observer observer)
        {
            observers.add(observer);
        }    
        //删除观察者方法
        public void remove(Observer observer)
        {
            observers.remove(observer);
        }   
        public abstract void notifyObserver(); //通知观察者方法
    }
    //具体目标
    class ConcreteSubject extends Subject
    {
        public void notifyObserver()
        {
            System.out.println("具体目标发生改变...");
            System.out.println("--------------");       

            for(Object obs:observers)
            {
                ((Observer)obs).response();
            }

        }          
    }
    //抽象观察者
    interface Observer
    {
        void response(); //反应
    }
    //具体观察者1
    class ConcreteObserver1 implements Observer
    {
        public void response()
        {
            System.out.println("具体观察者1作出反应！");
        }
    }
    //具体观察者1
    class ConcreteObserver2 implements Observer
    {
        public void response()
        {
            System.out.println("具体观察者2作出反应！");
        }
    }

19.中介者模式
---------
中介者（Mediator）模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。

中介者模式是一种对象行为型模式，其主要优点如下。
降低了对象之间的耦合性，使得对象易于独立地被复用。
将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。

其主要缺点是：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。

中介者模式包含以下主要角色。
抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。
具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。
抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。
具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。

    package mediator;
    import java.util.*;
    public class MediatorPattern
    {
        public static void main(String[] args)
        {
            Mediator md=new ConcreteMediator();
            Colleague c1,c2;
            c1=new ConcreteColleague1();
            c2=new ConcreteColleague2();
            md.register(c1);
            md.register(c2);
            c1.send();
            System.out.println("-------------");
            c2.send();
        }
    }
    //抽象中介者
    abstract class Mediator
    {
        public abstract void register(Colleague colleague);
        public abstract void relay(Colleague cl); //转发
    }
    //具体中介者
    class ConcreteMediator extends Mediator
    {
        private List<Colleague> colleagues=new ArrayList<Colleague>();
        public void register(Colleague colleague)
        {
            if(!colleagues.contains(colleague))
            {
                colleagues.add(colleague);
                colleague.setMedium(this);
            }
        }
        public void relay(Colleague cl)
        {
            for(Colleague ob:colleagues)
            {
                if(!ob.equals(cl))
                {
                    ((Colleague)ob).receive();
                }   
            }
        }
    }
    //抽象同事类
    abstract class Colleague
    {
        protected Mediator mediator;
        public void setMedium(Mediator mediator)
        {
            this.mediator=mediator;
        }   
        public abstract void receive();   
        public abstract void send();
    }
    //具体同事类
    class ConcreteColleague1 extends Colleague
    {
        public void receive()
        {
            System.out.println("具体同事类1收到请求。");
        }   
        public void send()
        {
            System.out.println("具体同事类1发出请求。");
            mediator.relay(this); //请中介者转发
        }
    }
    //具体同事类
    class ConcreteColleague2 extends Colleague
    {
        public void receive()
        {
            System.out.println("具体同事类2收到请求。");
        }   
        public void send()
        {
            System.out.println("具体同事类2发出请求。");
            mediator.relay(this); //请中介者转发
        }
    }

20.迭代器模式
---------
迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式，其主要优点如下。
访问一个聚合对象的内容而无须暴露它的内部表示。
遍历任务交由迭代器完成，这简化了聚合类。
它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。
增加新的聚合类和迭代器类都很方便，无须修改原有代码。
封装性良好，为遍历不同的聚合结构提供一个统一的接口。

其主要缺点是：增加了类的个数，这在一定程度上增加了系统的复杂性。

迭代器模式主要包含以下角色。
抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。
具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。
抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。
具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。

    package iterator;
    import java.util.*;
    public class IteratorPattern
    {
        public static void main(String[] args)
        {
            Aggregate ag=new ConcreteAggregate(); 
            ag.add("中山大学"); 
            ag.add("华南理工"); 
            ag.add("韶关学院");
            System.out.print("聚合的内容有：");
            Iterator it=ag.getIterator(); 
            while(it.hasNext())
            { 
                Object ob=it.next(); 
                System.out.print(ob.toString()+"\t"); 
            }
            Object ob=it.first();
            System.out.println("\nFirst："+ob.toString());
        }
    }
    //抽象聚合
    interface Aggregate
    { 
        public void add(Object obj); 
        public void remove(Object obj); 
        public Iterator getIterator(); 
    }
    //具体聚合
    class ConcreteAggregate implements Aggregate
    { 
        private List<Object> list=new ArrayList<Object>(); 
        public void add(Object obj)
        { 
            list.add(obj); 
        }
        public void remove(Object obj)
        { 
            list.remove(obj); 
        }
        public Iterator getIterator()
        { 
            return(new ConcreteIterator(list)); 
        }     
    }
    //抽象迭代器
    interface Iterator
    {
        Object first();
        Object next();
        boolean hasNext();
    }
    //具体迭代器
    class ConcreteIterator implements Iterator
    { 
        private List<Object> list=null; 
        private int index=-1; 
        public ConcreteIterator(List<Object> list)
        { 
            this.list=list; 
        } 
        public boolean hasNext()
        { 
            if(index<list.size()-1)
            { 
                return true;
            }
            else
            {
                return false;
            }
        }
        public Object first()
        {
            index=0;
            Object obj=list.get(index);;
            return obj;
        }
        public Object next()
        { 
            Object obj=null; 
            if(this.hasNext())
            { 
                obj=list.get(++index); 
            } 
            return obj; 
        }   
    }

21.访问者模式
----------
访问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。

访问者（Visitor）模式是一种对象行为型模式，其主要优点如下。
扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。
灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。
符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。

访问者（Visitor）模式的主要缺点如下。
增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。
破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。
违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。

    package visitor;
    import java.util.*;
    public class VisitorPattern
    {
        public static void main(String[] args)
        {
            ObjectStructure os=new ObjectStructure();
            os.add(new ConcreteElementA());
            os.add(new ConcreteElementB());
            Visitor visitor=new ConcreteVisitorA();
            os.accept(visitor);
            System.out.println("------------------------");
            visitor=new ConcreteVisitorB();
            os.accept(visitor);
        }
    }
    //抽象访问者
    interface Visitor
    {
        void visit(ConcreteElementA element);
        void visit(ConcreteElementB element);
    }
    //具体访问者A类
    class ConcreteVisitorA implements Visitor
    {
        public void visit(ConcreteElementA element)
        {
            System.out.println("具体访问者A访问-->"+element.operationA());
        }
        public void visit(ConcreteElementB element)
        {
            System.out.println("具体访问者A访问-->"+element.operationB());
        }
    }
    //具体访问者B类
    class ConcreteVisitorB implements Visitor
    {
        public void visit(ConcreteElementA element)
        {
            System.out.println("具体访问者B访问-->"+element.operationA());
        }
        public void visit(ConcreteElementB element)
        {
            System.out.println("具体访问者B访问-->"+element.operationB());
        }
    }
    //抽象元素类
    interface Element
    {
        void accept(Visitor visitor);
    }
    //具体元素A类
    class ConcreteElementA implements Element
    {
        public void accept(Visitor visitor)
        {
            visitor.visit(this);
        }
        public String operationA()
        {
            return "具体元素A的操作。";
        }
    }
    //具体元素B类
    class ConcreteElementB implements Element
    {
        public void accept(Visitor visitor)
        {
            visitor.visit(this);
        }
        public String operationB()
        {
            return "具体元素B的操作。";
        }
    }
    //对象结构角色
    class ObjectStructure
    {   
        private List<Element> list=new ArrayList<Element>();   
        public void accept(Visitor visitor)
        {
            Iterator<Element> i=list.iterator();
            while(i.hasNext())
            {
                ((Element) i.next()).accept(visitor);
            }      
        }
        public void add(Element element)
        {
            list.add(element);
        }
        public void remove(Element element)
        {
            list.remove(element);
        }
    }

22.备忘录模式
----------
备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。

备忘录模式是一种对象行为型模式，其主要优点如下。
提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。
实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。
简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。

其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。

备忘录模式的主要角色如下。
发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。
备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。
管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。

备忘录模式的结构图如图所示。

![image](https://github.com/undefiersun/java-note/blob/master/images/3-1Q119130413927.gif)

    package memento;
    public class MementoPattern
    {
        public static void main(String[] args)
        {
            Originator or=new Originator();
            Caretaker cr=new Caretaker();       
            or.setState("S0"); 
            System.out.println("初始状态:"+or.getState());           
            cr.setMemento(or.createMemento()); //保存状态      
            or.setState("S1"); 
            System.out.println("新的状态:"+or.getState());        
            or.restoreMemento(cr.getMemento()); //恢复状态
            System.out.println("恢复状态:"+or.getState());
        }
    }
    //备忘录
    class Memento
    { 
        private String state; 
        public Memento(String state)
        { 
            this.state=state; 
        }     
        public void setState(String state)
        { 
            this.state=state; 
        }
        public String getState()
        { 
            return state; 
        }
    }
    //发起人
    class Originator
    { 
        private String state;     
        public void setState(String state)
        { 
            this.state=state; 
        }
        public String getState()
        { 
            return state; 
        }
        public Memento createMemento()
        { 
            return new Memento(state); 
        } 
        public void restoreMemento(Memento m)
        { 
            this.setState(m.getState()); 
        } 
    }
    //管理者
    class Caretaker
    { 
        private Memento memento;       
        public void setMemento(Memento m)
        { 
            memento=m; 
        }
        public Memento getMemento()
        { 
            return memento; 
        }
    }

23.解释器模式
----------

